use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;
use js_sys::Promise;

use crate::profile::Profile;
use crate::api::Api;


/// A block object.
#[wasm_bindgen]
#[derive(Debug, Serialize, Deserialize)]
pub struct Block {
    public: String,
    group: String,
    key: String,
    version: u64,
    data: String,
    signature: String,
}


#[wasm_bindgen]
impl Block {
    /// Creates an empty block.
    pub fn new(publicKey: &str, group: &str, key: &str) -> Self {
        Self {
            public: publicKey.to_string(),
            group: group.to_string(),
            key: key.to_string(),
            version: 0,
            data: "".to_string(),
            signature: "".to_string(),
        }
    }

    /// Creates a block from given JSON.
    pub fn fromBlockJson(blockJson: &JsValue) -> Self {
        // Create Block object
        let block: Self = blockJson.into_serde().unwrap();

        // Check signature
        let iscorrect = Profile::checkSignature(
            &block.public, &block.group, &block.key,
            block.version, &block.data, &block.signature
        );
        assert!(iscorrect);

        // Return
        block
    }

    /// Gets the public key.
    pub fn publicKey(&self) -> String {
        self.public.clone()
    }

    /// Gets the group.
    pub fn group(&self) -> String {
        self.group.clone()
    }

    /// Gets the key.
    pub fn key(&self) -> String {
        self.key.clone()
    }

    /// Gets the version.
    pub fn version(&self) -> u64 {
        self.version
    }

    /// Gets the data.
    pub fn data(&self) -> String {
        self.data.clone()
    }

    /// Gets the signature.
    pub fn signature(&self) -> String {
        self.signature.clone()
    }

    /// Increments the version (it clears the signature).
    pub fn incVersion(&mut self) {
        self.version += 1;
        self.clearSignature();
    }

    /// Sets new data to the block (it clears the signature).
    pub fn setData(&mut self, data: &str) {
        self.data = data.to_string();
        self.clearSignature();
    }

    /// Checks whether a non-empty signature exists.
    pub fn isSigned(&self) -> bool {
        !self.signature.is_empty()
    }

    /// Sets the signature generated by the block data and given profile
    /// object.
    pub fn sign(&mut self, profile: &Profile) {
        assert_eq!(self.public, profile.publicKey());
        self.signature = profile.buildSignature(
            &self.group, &self.key, self.version, &self.data
        );
    }

    /// Clears the signature.
    pub fn clearSignature(&mut self) {
        self.signature = "".to_string();
    }

    /// Updated the block as it is on the hashstorage backend without any extra
    /// modifications. Use `save` if you need to increment the version,
    /// sign the block and updates it at once.
    pub fn update(&self, api: &Api) -> Promise {
        api.postData(
            &self.public, &self.group, &self.key,
            self.version, &self.data, &self.signature
        )
    }

    /// Saves the block data on the hashstorage backend. It includes
    /// the version incrementing, building the signature and the request to
    /// the server. Use `update` if you just need to save the block as it is.
    pub fn save(&mut self, api: &Api, profile: &Profile) -> Promise {
        self.incVersion();
        self.sign(profile);
        self.update(api)
    }
}
